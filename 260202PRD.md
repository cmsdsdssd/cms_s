# [CODING AGENT PROMPT] 공장 영수증 기반 원가/AP(공장미수) + 수리 플로우 완성 (Shipments/AR 연동)

## 0) 필수 전제/프로젝트 룰(절대 위반 금지)
- DB SoT는 **public.cms_*** 오브젝트만. **ms_s 사용 금지**
- **직접 INSERT/UPDATE 금지** → 쓰기는 반드시 **RPC(Function)** 로만
- 마이그레이션은 **ADD-ONLY** (기존 migration 수정/재작성 금지)
- 새 migration 파일명은 **타임스탬프를 현재 repo에서 가장 큰 값보다 “더 뒤(미래)”로** 잡아 마지막에 오게 만들 것 (db push 예정)
- RPC는 **SECURITY DEFINER / WITH EXECUTE AS OWNER** 패턴 유지 + 필요한 EXECUTE 권한 부여
- RLS/권한/컨벤션은 코드베이스 기존 패턴 그대로 재사용
- 프론트는 기존 컴포넌트/훅(SearchSelect, Modal, ActionBar, useRpcMutation 등) 재사용 우선

## 1) 작업 방식(반드시)
1) 코드베이스를 먼저 훑어 아래를 파악/재사용:
   - 공장 영수증/원가/매입채무(AP) 관련 테이블/뷰/RPC가 이미 있는지
   - 영수증 작업대(원가기록대) 화면/라인 작성 로직이 어디에 있는지(컴포넌트/훅/유효성검사 포함)
   - repairs 관련 cms_repair* / 페이지(/repairs) / RPC 존재 여부
   - shipment confirm 시 AR(미수/원장) 반영 로직 위치/패턴(멱등키 포함)
2) “왜 지금 기능이 실사용이 어려운지” 원인 **각 주제별 3~5개**를 짧게 요약
3) 이후 **최소 변경 + 기존 패턴 재사용**으로 구현
4) 산출물은 반드시: migration SQL + RPC SQL + 프론트 diff(또는 전체 파일) + 수동 테스트 체크리스트

---

# [주제 1] 공장 영수증(매입원가) 입력 1번으로 AP(공장미수) 생성 + 원가 확정/배분까지 이어지게

## 1-1) 목표(업무 흐름)
- 현재: “미수관리”가 소매상(AR) 중심만 존재
- 추가: 공장에서 받은 **영수증 입력(원가기록)** 을 기반으로
  1) **공장별 매입채무(AP / 공장미수)** 를 기록
  2) (가능하면) 해당 영수증을 **출고(Shipments)와 링크/배분**해 “원가 확정” 상태로 전환
- 핵심: **출고를 영수증 선행으로 강제하지 말 것**
  - 출고는 “임시원가(provisional)”로 가능
  - 공장 결제/AP 정산은 영수증 기반으로만 가능(여기서만 강제)

## 1-2) UX 요구사항(MVP)
### A) 원가기록(공장 영수증) 화면/플로우
- Step A: 공장(Party) 검색/선택 (SearchSelect)
- Step B: 영수증 헤더 입력(영수증번호/일자/메모 등 최소)

- ✅ Step C: **영수증 라인 입력은 “절대 새로 만들지 말고”**
  - 현재 사용 중인 **영수증 작업대(원가기록대) 라인 작성 UI/로직을 그대로 재사용**할 것
  - 필드 구성/입력 방식/자동완성/검증/합계 계산/라인 추가·삭제 UX 등 **기존 동작을 변경 금지**
  - “라인 입력 결과가 어떤 데이터 구조로 저장되는지”를 먼저 확인하고, 그 구조에 맞춰 **뒤 로직(AP 생성/배분/원가확정)만 추가**해라
  - 즉, Step C는 “그대로 두고”, Step D~E만 확장하는 방식으로 구현

- Step D: 저장 시 **AP(공장미수) 생성**
- Step E(중요): “이 영수증을 출고에 적용(Apply)” 기능
  - 미확정 원가 출고 목록을 보여주고(필터: 거래처/모델/일자)
  - 다건 선택 후 “배분 방식” 선택:
    - (기본) **임시원가 비율로 배분** 또는 **수량 비율** 중 하나를 MVP로 채택
  - Apply 시: 연결/배분 기록 저장 + 해당 출고들의 원가 상태를 “확정됨”으로 표시

### B) Shipments 화면 표시
- “원가상태 배지”: 미확정/확정
- 출처/링크(연결된 공장 영수증이 있으면 클릭 이동 가능)

## 1-3) DB 설계(먼저 기존 cms_* 재사용, 없으면 추가)
- 이미 유사한 테이블이 있으면 그걸 확장. 없으면 아래 최소 형태로 추가:
  - cms_vendor_bill (공장 영수증 헤더)
    - bill_id(pk), party_id(factory), bill_no, bill_date, notes
    - total_cost_krw numeric (혹은 라인 합으로 계산)
    - created_at, updated_at
  - cms_vendor_bill_line (영수증 라인)
    - bill_line_id(pk), bill_id(fk)
    - master_item_id 또는 model_no(프로젝트 기준에 맞춤)
    - qty, unit_cost_krw 또는 line_total_krw(택1, MVP는 line_total만도 OK)
  - cms_vendor_bill_allocation (영수증 → 출고 배분/링크)
    - allocation_id(pk)
    - bill_id(fk), shipment_id(fk) 또는 shipment_line_id(fk) (가능하면 라인 단위)
    - allocated_cost_krw numeric
    - unique 제약(중복 배분/중복 적용 방지)
- Shipments/원가 스냅샷에 아래 중 하나로 “확정원가” 반영:
  - (권장) shipment confirm 시 참조하는 **cost snapshot** 테이블/로직을 확장해
    - provisional_cost_krw(기존 있으면 활용)
    - actual_cost_krw(=배분된 원가 합)
    - cost_status enum(UNCONFIRMED/CONFIRMED)
  - ※ 기존 구조를 먼저 확인하고 “있는 곳에 최소 확장”할 것

## 1-4) RPC(필수)
- 기존 컨벤션/네이밍에 맞춰 구현(아래는 예시)
1) cms_fn_create_vendor_bill_v1(party_id, bill_no, bill_date, notes, lines[]) -> bill_id
   - 저장 + 라인 입력 + total 계산
   - 생성과 동시에 **AP(공장미수) 기록 생성**(기존 원장 테이블 패턴 재사용)
   - 멱등키(예: party_id + bill_no) 또는 unique로 중복 생성 방지
2) cms_fn_apply_vendor_bill_to_shipments_v1(bill_id, allocations[]) -> void
   - allocations: [{shipment_id(or shipment_line_id), allocated_cost_krw}]
   - allocated_cost 합이 bill total과 맞는지(또는 허용오차) 검증
   - 배분 테이블 upsert/insert (중복 방지)
   - 해당 shipment의 cost_status/actual_cost 갱신은 RPC 내부에서(프로젝트 패턴대로)
3) (선택) cms_fn_set_vendor_bill_status_v1 / cms_fn_pay_ap_v1 등은 범위 밖이면 스킵 가능(MVP는 생성+배분까지만)

## 1-5) AR/원장 연동(안전 규칙)
- 공장 영수증은 **AP(공장미수)** 로 기록 (AR과 분리)
- 출고 확정 시 AR(소매상 미수)은 기존 로직 유지
- 수익분석은 “actual_cost 확정된 건만 정확” 표기(미확정은 별도 카운트)

---

# [주제 2] Repairs 플로우 완성 + Shipments 전환 + 추가수리비 AR 상계

## 2-1) 목표
거래처 선택 → 모델 선택 → 수리 접수 → 진행/완료 → “출고로 보내기” 전환 → 추가 수리비/사유 입력 → 출고 확정 시 AR(미수/원장)에 합산(멱등)

## 2-2) UX 요구사항(필수)
A) 수리 접수(생성)
- /repairs 에 “수리 접수” 버튼
- 모달/페이지 흐름:
  1) 거래처 SearchSelect
  2) 모델 검색(모델명/모델번호) → master_item/카탈로그 검색 재사용
  3) 증상/요청사항(필수), 메모(선택), 수량(기본 1)
  4) 저장 → 수리 상세로 이동 + toast

B) 수리 목록/필터
- 필터: 상태(접수/진행/완료/출고전환됨/취소), 거래처, 모델 검색
- 각 행 상태 배지 명확

C) 수리 완료 → 출고로 보내기
- 수리 상세 버튼:
  - “수리 완료 처리”
  - “출고로 보내기”
- “출고로 보내기” 모달:
  - extra_repair_fee_krw (0 가능)
  - extra_repair_fee_reason (fee>0이면 필수)
- 확인 시:
  1) 수리 상태 “출고대기/출고전환됨”으로 전환
  2) Shipments에 연결 객체(출고 초안) 생성 + source_type='REPAIR', source_id=repair_id 방식 권장
  3) fee/reason을 shipment(또는 cost/settlement snapshot)에 포함(확정 시 반영)

## 2-3) DB 설계(기존 cms_repair* 재사용 우선, 없으면 추가)
- cms_repair
  - repair_id(pk), party_id, status(enum), notes, created_at, updated_at
- cms_repair_line
  - repair_id fk
  - master_item_id 또는 model_no
  - qty
  - issue_desc(필수)
- extra fee는 MVP로 repair 헤더에 단일 필드 허용:
  - extra_repair_fee_krw numeric
  - extra_repair_fee_reason text

## 2-4) RPC(필수)
1) cms_fn_create_repair_v1(party_id, notes, lines[]) -> repair_id
2) cms_fn_set_repair_status_v1(repair_id, status) -> void
3) cms_fn_send_repair_to_shipment_v1(repair_id, extra_fee_krw, extra_fee_reason) -> shipment_id
   - extra_fee_krw>0 && reason empty → ERROR
   - shipment 초안 생성 + repair↔shipment 링크
   - repair status를 출고전환됨으로 변경
   - extra fee/reason 스냅샷 저장
   - 멱등: 동일 repair_id로 두 번 전환 호출 시 중복 shipment 생성/원장 반영 방지(unique / idempotency key)

## 2-5) Shipments 확정 시 AR(미수/원장) 반영 규칙(가장 중요)
- “추가 수리비”는 **출고 확정(정산 확정) 시점에 AR에 반영**
- 기존 confirm_shipment 로직에 아래를 확장:
  - repair_extra_fee_krw 를 총액/미수 계산에 합산
  - reason은 원장/로그에 남아 추적 가능
  - 비용=0이면 영향 없음
  - **중복 반영 방지**(기존 멱등키/unique 키 패턴 그대로 적용)

---

# 3) 구현 산출물(필수 제출)
1) ✅ 새 migration SQL 파일들(ADD-ONLY, 타임스탬프 “가장 뒤”)
2) ✅ RPC SQL(SECURITY DEFINER/EXECUTE AS OWNER + 권한부여 포함)
3) ✅ 프론트 수정(diff 또는 전체 파일)
   - /repairs (목록/상세/접수)
   - 출고 전환 모달(extra fee + reason)
   - Shipments: repair 출처 배지/표기 + 원가상태 배지(주제1)
4) ✅ 수동 테스트 체크리스트

## 4) 최소 테스트 시나리오(반드시 통과)
[주제1]
- 공장 영수증 생성(현 영수증 작업대 라인 입력 그대로) → AP(공장미수) 생성 OK(중복 생성 방지)
- 영수증 Apply(배분) → 연결/배분 저장 OK, shipment 원가상태 “확정” 표시 OK
- 미확정 shipment는 그대로 출고 가능(차단 금지), 단 원가상태 표시 OK

[주제2]
- 거래처 선택 → 모델 선택 → 수리 접수 저장 OK
- 상태 변경(접수→진행→완료) OK
- 출고로 보내기(fee=0) → shipment 생성/연결 OK, 원장 반영 없음
- 출고로 보내기(fee>0, reason 필수) → shipment 연결 OK
- shipment 확정 → AR/원장에 extra fee 반영 OK, **중복 반영 없음**

---

# 5) 품질 게이트(제출물에 포함)
- 기존 패턴 재사용/최소 변경 근거
- migration 타임스탬프/정렬 및 db push 통과 확인 포인트
- “왜 실사용이 안 됐는지” 원인 요약(각 주제별 3~5개)
